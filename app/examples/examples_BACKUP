// TODO: Ignore ignored files.
// TODO: Handle folders (and symlinks?) differently.
//
// Usage:
//     examples.Register({ db: session })
//
//

package examples

import (
	"log"
	"net/url"

	"gopkg.in/mgo.v2/bson"

	"github.com/ongoingio/site/app/database"
	"github.com/ongoingio/site/app/repository"
)

// TODO: "gopkg.in/mgo.v2" gets auto-removed by goimports.
var collection *mgo.Collection

// Example represents an Example.
type Example struct {
	Path        string
	Type        string
	Alias       string
	Name        string
	SHA         string
	Description string
	Content     string
}

/*
// TODO: Possible to List() as a method?
func List() []Example {
	return data
}
*/

/*
// TODO: Return a pointer or an error? Most ORM seem to be using `err := Find(&example, "name-1")`
func FindByName(name string) (Example, error) {
	for _, e := range data {
		if e.Name == name {
			return e, nil
		}
	}

	return Example{}, fmt.Errorf("%s not found", name)
}
*/

// TODO: Method on Examples or Example?
func generateAlias(name string) string {
	return url.QueryEscape(name)
}

// Save saves an example.
func (example *Example) Save() error {
	err := collection.Insert(example)
	if err != nil {
		return err
	}

	return nil
}

// UpdateByPath updates an example with the given path.
func (example *Example) UpdateByPath(path string) error {
	colQuerier := bson.M{"path": path}
	change := bson.M{"$set": example}
	err := collection.Update(colQuerier, change)
	if err != nil {
		return err
	}

	return nil
}

// Prepare prepares the example with additional content.
func (example *Example) Prepare(content repository.Content) error {
	example.Type = content.Type
	example.Alias = generateAlias(content.Name)
	example.Name = content.Name
	example.SHA = content.SHA
	example.Path = content.Path

	// TODO: Extract description from file (via parse package).
	example.Description = "Some description..."

	// TODO: Prepare() in goroutine.
	err := content.Fetch()
	if err != nil {
		return err
	}
	example.Content = content.Content

	return nil
}

// Sync synchronizes the database with the Github repository.
func Sync() error {
	repo := repository.New("https://api.github.com/repos/ongoingio/examples/")
	repoContent, err := repo.Fetch()
	if err != nil {
		log.Fatal(err)
	}

	for _, content := range repoContent.Content {
		result := Example{}
		err = collection.Find(bson.M{"path": content.Path}).One(&result)
		switch {
		case err == mgo.ErrNotFound:
			log.Printf("DEBUG: Doc %s not found.", content.Path)
			example := &Example{}
			example.Prepare(content)
			example.Save()
		case err != nil:
			return err
		case content.SHA != result.SHA:
			log.Printf("DEBUG: Doc %s found, but needs updating.", content.Path)
			example := &Example{}
			example.Prepare(content)
			example.UpdateByPath(content.Path)
		default:
			log.Printf("DEBUG: Doc %s found.", content.Path)
		}
	}

	return nil
}

// Register registers the database collection.
func Register() {
	collection = database.Session.DB("ongoingio").C("examples")
}
